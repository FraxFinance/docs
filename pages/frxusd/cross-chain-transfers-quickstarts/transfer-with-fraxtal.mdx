---
title: Transfer frxUSD with Fraxtal
lang: en-US
---

# Transfer frxUSD with Fraxtal

This guide demonstrates how to use the viem framework in a simple script that enables a user to transfer frxUSD with Fraxtal as the destination or source chain using the Lockbox addresses listed on the [FraxZero Lockbox addresses](/frxusd/fraxzero-supported-networks).

**Note:** This guide does not support frxUSD transfers where Fraxtal is neither the source nor destination chain.

## Prerequisites

Before you start building the sample app to perform a frxUSD transfer, ensure you have met the following prerequisites:

1. **Install Node.js and npm**

   - Download and install **Node.js** directly or use a version manager like **nvm**.
   - **npm** is included with Node.js.

2. **Set up a non-custodial wallet** (for example, MetaMask)

   - You can download, install, and create a **MetaMask** wallet from its official website.
   - During setup, create a wallet on **Ethereum mainnet**.
   - Retrieve the **private key** for your wallet, as it will be required in the script below.

3. **Fund your wallet with the gas token on the source chain**

## Project setup

To build the script, first set up your project environment and install the required dependencies.

### 1. Set up a new project

Create a new directory and initialize a new `Node.js` project with default settings:

```shell
mkdir frxusd-cross-chain-transfers-with-fraxtal
cd frxusd-cross-chain-transfers-with-fraxtal
npm init -y
```

This also creates a default `package.json` file.

### 2. Install dependencies

In your project directory, install the required dependencies, including `viem`:

```shell
npm install dotenv@^16.4.7 viem@^2.23.4
```

This sets up your development environment with the necessary libraries for building the script. It also updates the `package.json` file with the dependencies.

### 3. Add module type

Add `"type": "module"` to the `package.json` file:

```json
{
  "name": "frax-cross-chain-transfer",
  "version": "1.0.0",
  "type": "module",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "node transfer.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "dotenv": "^16.4.7",
    "viem": "^2.23.4"
  }
}
```

### 4. Configure environment variables

Create a `.env` file in your project directory and add your wallet private key:

```shell
echo "PRIVATE_KEY=your-private-key-here" > .env
```

**Warning:** This is strictly for testing purposes. **Never share your private key**.

## Script setup

This section covers the necessary setup for the transfer.js script, including defining keys and addresses, and configuring the wallet client for interacting with the source and destination chains.

### 1. Replace with your private key and wallet address

Ensure that this section of the file includes your **private key** and associated **wallet address**. The script also predefines the **RemoteHop contract address**, the **transfer amount**, and the **max fee**. These definitions are critical for successfully transferring frxUSD between the intended wallets.

```javascript
// ============ Configuration Constants ============

// Authentication
const PRIVATE_KEY = process.env.PRIVATE_KEY;
const account = privateKeyToAccount(`0x${PRIVATE_KEY}`);

// LockBox Contract Addresses and Destination EID
const ETHEREUM_MAINNET_LOCKBOX_ADDRESS = '0x3ad4dC2319394bB4BE99A0e4aE2AbF7bCEbD648E'; // Lockbox contract address (used for Ethereum -> Fraxtal transfers)
const FRAXTAL_MAINNET_LOCKBOX_ADDRESS = '0x96A394058E2b84A89bac9667B19661Ed003cF5D4'; // Lockbox contract address (used for Fraxtal -> Ethereum transfers)
const ARBITRUM_MAINNET_FRXUSD_ADDRESS = '0x29F5DBD0FE72d8f11271FCBE79Cb87E18a83C70A'; // frxUSD token contract address (used for Arbitrum -> Fraxtal transfers).
const DESTINATION_ADDRESS = '0x1234567890123456789012345678901234567890'; // Recipient address
const DESTINATION_ADDRESS_BYTES32 = `0x000000000000000000000000${DESTINATION_ADDRESS.slice(2)}`; // Convert to bytes32 format

// Transfer Parameters
const TRANSFER_AMOUNT = 10_000_000_000_000_000_000n; // 10 frxUSD
```

### 2. Set up wallet clients

The **wallet clients** configures the appropriate network settings using `viem`. In this example, the script will be transferring frxUSD from **Ethereum mainnet** to **Arbitrum mainnet**.

```javascript
// Set up a wallet client on the source chain
const ethereumClient = createWalletClient({
  chain: mainnet,
  transport: http(),
  account,
});

const fraxtalClient = createWalletClient({
  chain: fraxtal,
  transport: http(),
  account,
});

const arbitrumClient = createWalletClient({
  chain: arbitrum,
  transport: http(),
  account,
});
```

### 3. Determine the spender address

The spender address is the address that will be used to transfer frxUSD. You should use the following table to determine the spender address for your transfer:

| Source Chain                   | Destination Chain | Spender Address                    |
| ------------------------------ | ----------------- | ---------------------------------- |
| Ethereum                       | Fraxtal           | `ETHEREUM_MAINNET_LOCKBOX_ADDRESS` |
| Fraxtal                        | Ethereum          | `FRAXTAL_MAINNET_LOCKBOX_ADDRESS`  |
| Arbitrum (or other EVM chains) | Fraxtal           | `ARBITRUM_MAINNET_FRXUSD_ADDRESS`  |

**Note:** For Arbitrum, you can replace it with any other EVM-compatible chain where frxUSD is deployed (besides Fraxtal and Ethereum).

In this example for our sample transfer, we will be transferring frxUSD from **Ethereum mainnet** to **Fraxtal mainnet**. Therefore, we will be using the `ARBITRUM_MAINNET_FRXUSD_ADDRESS` as our spender address.

```javascript
const spenderAddress = FRAXTAL_MAINNET_LOCKBOX_ADDRESS;
const sourceChainClient = fraxtalClient;
const FRAXTAL_MAINNET_FRXUSD_ADDRESS = '0xfc00000000000000000000000000000000000001'; // frxUSD token contract address on Fraxtal mainnet
```

## frxUSD cross-chain transfer process

The following sections outline the relevant transfer logic of the sample script. In this example, we are transferring frxUSD from **Ethereum mainnet** to **Arbitrum mainnet**. Follow the steps below to perform the transfer:

### 1. Approve frxUSD

The first step is to grant approval for the spender address:

**Note:** If the source chain is **Arbitrum mainnet** (or other EVM chains) and the destination chain is **Fraxtal mainnet**, you do not need to approve the frxUSD token. The approval is only required between **Ethereum mainnet** and **Fraxtal mainnet**.

```javascript
async function approveFrxUSD(sourceChainClient, frxUsdTokenAddress, spenderAddress) {
  console.log('Approving frxUSD transfer...');
  const approveTx = await sourceChainClient.sendTransaction({
    to: frxUsdTokenAddress,
    data: encodeFunctionData({
      abi: [
        {
          type: 'function',
          name: 'approve',
          stateMutability: 'nonpayable',
          inputs: [
            { name: 'spender', type: 'address' },
            { name: 'amount', type: 'uint256' },
          ],
          outputs: [{ name: '', type: 'bool' }],
        },
      ],
      functionName: 'approve',
      args: [spenderAddress, TRANSFER_AMOUNT], // Set max allowance in wei (change as needed)
    }),
  });
  console.log(`frxUSD Approval Tx: ${approveTx}`);
}
```

### 2. Retrieve FraxZero Quote

In this step, you call the `quote` function on the spender address you determined in the prior step via the table:

- **Destination EID**: The EID of the destination chain (EIDs can be found [here](/frxusd/fraxzero-supported-networks))
- **Destination address**: The wallet address that will receive the transferred frxUSD (in bytes32 format)
- **Amount**: The amount of frxUSD to transfer (in wei)
- **Minimum amount**: The minimum amount of frxUSD to receive (in wei)
- **Extra options**: The extra options for the transfer
- **Compose message**: The compose message for the transfer
- **OFT command**: The OFT command for the transfer

The quote function returns the native fee amount required for the transfer.

```javascript
async function retrieveQuote(sourceChainClient, spenderAddress, destinationEid) {
  console.log('Retrieving quote...');
  const quote = await sourceChainClient.readContract({
    address: spenderAddress,
    data: encodeFunctionData({
      abi: [
        {
          inputs: [
            {
              components: [
                { internalType: 'uint32', name: 'dstEid', type: 'uint32' },
                { internalType: 'bytes32', name: 'to', type: 'bytes32' },
                { internalType: 'uint256', name: 'amountLD', type: 'uint256' },
                { internalType: 'uint256', name: 'minAmountLD', type: 'uint256' },
                { internalType: 'bytes', name: 'extraOptions', type: 'bytes' },
                { internalType: 'bytes', name: 'composeMsg', type: 'bytes' },
                { internalType: 'bytes', name: 'oftCmd', type: 'bytes' },
              ],
              internalType: 'struct SendParam',
              name: '_sendParam',
              type: 'tuple',
            },
            { internalType: 'bool', name: '_payInLzToken', type: 'bool' },
          ],
          name: 'quoteSend',
          outputs: [
            {
              components: [
                { internalType: 'uint256', name: 'nativeFee', type: 'uint256' },
                { internalType: 'uint256', name: 'lzTokenFee', type: 'uint256' },
              ],
              internalType: 'struct MessagingFee',
              name: 'msgFee',
              type: 'tuple',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
      ],
      functionName: 'quoteSend',
      args: [
        {
          dstEid: destinationEid,
          to: DESTINATION_ADDRESS_BYTES32,
          amountLD: TRANSFER_AMOUNT,
          minAmountLD: (TRANSFER_AMOUNT * 99n) / 100n,
          extraOptions: '0x',
          composeMsg: '0x',
          oftCmd: '0x',
        },
        false,
      ],
    }),
  });
  const nativeFee = quote.nativeFee;
  return nativeFee;
}
```

### 3. Transfer frxUSD

After retrieving the native fee amount, you can call the `send` function on the spender address you determined in the prior step via the table. This function takes the following parameters:

- **Destination EID**: The EID of the destination chain
- **Destination address**: The wallet address that will receive the transferred frxUSD (in bytes32 format)
- **Amount**: The amount of frxUSD to transfer (in wei)
- **Minimum amount**: The minimum amount of frxUSD to receive (in wei)
- **Extra options**: The extra options for the transfer
- **Compose message**: The compose message for the transfer
- **OFT command**: The OFT command for the transfer
- **Native fee**: The native fee for the transfer
- **Lz token fee**: The lz token fee for the transfer
- **Refund address**: The refund address for the transfer

```javascript
async function transferFrxUSD() {
  console.log('Transferring frxUSD...');
  const nativeFee = await retrieveQuote();
  const transferTx = await ethereumClient.sendTransaction({
    to: spenderAddress,
    value: nativeFee,
    data: encodeFunctionData({
      abi: [
        {
          inputs: [
            {
              components: [
                { internalType: 'uint32', name: 'dstEid', type: 'uint32' },
                { internalType: 'bytes32', name: 'to', type: 'bytes32' },
                { internalType: 'uint256', name: 'amountLD', type: 'uint256' },
                { internalType: 'uint256', name: 'minAmountLD', type: 'uint256' },
                { internalType: 'bytes', name: 'extraOptions', type: 'bytes' },
                { internalType: 'bytes', name: 'composeMsg', type: 'bytes' },
                { internalType: 'bytes', name: 'oftCmd', type: 'bytes' },
              ],
              internalType: 'struct SendParam',
              name: '_sendParam',
              type: 'tuple',
            },
            {
              components: [
                { internalType: 'uint256', name: 'nativeFee', type: 'uint256' },
                { internalType: 'uint256', name: 'lzTokenFee', type: 'uint256' },
              ],
              internalType: 'struct MessagingFee',
              name: '_fee',
              type: 'tuple',
            },
            { internalType: 'address', name: '_refundAddress', type: 'address' },
          ],
          name: 'send',
          outputs: [
            {
              components: [
                { internalType: 'bytes32', name: 'guid', type: 'bytes32' },
                { internalType: 'uint64', name: 'nonce', type: 'uint64' },
                {
                  components: [
                    { internalType: 'uint256', name: 'nativeFee', type: 'uint256' },
                    { internalType: 'uint256', name: 'lzTokenFee', type: 'uint256' },
                  ],
                  internalType: 'struct MessagingFee',
                  name: 'fee',
                  type: 'tuple',
                },
              ],
              internalType: 'struct MessagingReceipt',
              name: 'msgReceipt',
              type: 'tuple',
            },
            {
              components: [
                { internalType: 'uint256', name: 'amountSentLD', type: 'uint256' },
                {
                  internalType: 'uint256',
                  name: 'amountReceivedLD',
                  type: 'uint256',
                },
              ],
              internalType: 'struct OFTReceipt',
              name: 'oftReceipt',
              type: 'tuple',
            },
          ],
          stateMutability: 'payable',
          type: 'function',
        },
      ],
      functionName: 'send',
      args: [
        {
          dstEid: destinationEid,
          to: DESTINATION_ADDRESS_BYTES32,
          amountLD: TRANSFER_AMOUNT,
          minAmountLD: (TRANSFER_AMOUNT * 99n) / 100n,
          extraOptions: '0x',
          composeMsg: '0x',
          oftCmd: '0x',
        },
        { nativeFee: nativeFee, lzTokenFee: 0n },
        account.address,
      ],
      value: nativeFee,
    }),
  });
  console.log(`Transfer Tx: ${transferTx}`);
}
```

## Build the script

Now that you understand the core steps for programmatically **transferring frxUSD** with **Fraxtal** as the source or destination chain using Frax's cross-chain infrastructure, create a `transfer.js` in your project directory and populate it with the sample code below.

**Note:** The source wallet must contain **native gas tokens** (to cover gas fees) and **frxUSD** to complete the transfer.

### transfer.js

```javascript
// Import environment variables
import 'dotenv/config';
import { createWalletClient, http, encodeFunctionData } from 'viem';
import { privateKeyToAccount } from 'viem/accounts';
import { mainnet, arbitrum, fraxtal } from 'viem/chains';

// ============ Configuration Constants ============

// Authentication
const PRIVATE_KEY = process.env.PRIVATE_KEY;
const account = privateKeyToAccount(`0x${PRIVATE_KEY}`);

// LockBox Contract Addresses and Destination EID
const ETHEREUM_MAINNET_LOCKBOX_ADDRESS = '0x3ad4dC2319394bB4BE99A0e4aE2AbF7bCEbD648E'; // Lockbox contract address (used for Ethereum -> Fraxtal transfers)
const FRAXTAL_MAINNET_LOCKBOX_ADDRESS = '0x96A394058E2b84A89bac9667B19661Ed003cF5D4'; // Lockbox contract address (used for Fraxtal -> Ethereum transfers)
const ARBITRUM_MAINNET_FRXUSD_ADDRESS = '0x29F5DBD0FE72d8f11271FCBE79Cb87E18a83C70A'; // frxUSD token contract address (used for Arbitrum -> Fraxtal transfers)
const FRAXTAL_MAINNET_FRXUSD_ADDRESS = '0xfc00000000000000000000000000000000000001'; // frxUSD token contract address on Fraxtal mainnet
const ETHEREUM_MAINNET_FRXUSD_ADDRESS = '0xCAcd6fd266aF91b8AeD52aCCc382b4e165586E29'; // frxUSD contract address on Ethereum mainnet

// EIDs for different chains
const FRAXTAL_MAINNET_EID = 30132; // EID of Fraxtal mainnet
const ETHEREUM_MAINNET_EID = 30101; // EID of Ethereum mainnet
const ARBITRUM_MAINNET_EID = 30110; // EID of Arbitrum mainnet

const DESTINATION_ADDRESS = '0x1234567890123456789012345678901234567890'; // Recipient address
const DESTINATION_ADDRESS_BYTES32 = `0x000000000000000000000000${DESTINATION_ADDRESS.slice(2)}`; // Convert to bytes32 format

// Transfer Parameters
const TRANSFER_AMOUNT = 10_000_000_000_000_000_000n; // 10 frxUSD

// Set up wallet clients for different chains
const ethereumClient = createWalletClient({
  chain: mainnet,
  transport: http(),
  account,
});

const fraxtalClient = createWalletClient({
  chain: fraxtal,
  transport: http(),
  account,
});

const arbitrumClient = createWalletClient({
  chain: arbitrum,
  transport: http(),
  account,
});

// Configuration for transfer direction
// Change these variables based on your transfer direction
const SOURCE_CHAIN = 'ethereum'; // Options: 'ethereum', 'fraxtal', 'arbitrum'
const DESTINATION_CHAIN = 'fraxtal'; // Options: 'ethereum', 'fraxtal', 'arbitrum'

// Determine spender address and client based on transfer direction
function getTransferConfig() {
  let spenderAddress, sourceChainClient, frxUsdTokenAddress, destinationEid;

  if (SOURCE_CHAIN === 'ethereum' && DESTINATION_CHAIN === 'fraxtal') {
    spenderAddress = ETHEREUM_MAINNET_LOCKBOX_ADDRESS;
    sourceChainClient = ethereumClient;
    frxUsdTokenAddress = ETHEREUM_MAINNET_FRXUSD_ADDRESS;
    destinationEid = FRAXTAL_MAINNET_EID;
  } else if (SOURCE_CHAIN === 'fraxtal' && DESTINATION_CHAIN === 'ethereum') {
    spenderAddress = FRAXTAL_MAINNET_LOCKBOX_ADDRESS;
    sourceChainClient = fraxtalClient;
    frxUsdTokenAddress = FRAXTAL_MAINNET_FRXUSD_ADDRESS;
    destinationEid = ETHEREUM_MAINNET_EID;
  } else if (SOURCE_CHAIN === 'arbitrum' && DESTINATION_CHAIN === 'fraxtal') {
    spenderAddress = ARBITRUM_MAINNET_FRXUSD_ADDRESS;
    sourceChainClient = arbitrumClient;
    frxUsdTokenAddress = ARBITRUM_MAINNET_FRXUSD_ADDRESS;
    destinationEid = FRAXTAL_MAINNET_EID;
  } else {
    throw new Error(
      'Unsupported transfer direction. This script only supports transfers where Fraxtal is either source or destination.',
    );
  }

  return { spenderAddress, sourceChainClient, frxUsdTokenAddress, destinationEid };
}

async function approveFrxUSD(sourceChainClient, frxUsdTokenAddress, spenderAddress) {
  console.log('Approving frxUSD transfer...');

  // Skip approval for Arbitrum -> Fraxtal transfers
  if (SOURCE_CHAIN === 'arbitrum' && DESTINATION_CHAIN === 'fraxtal') {
    console.log('Skipping approval for Arbitrum -> Fraxtal transfer');
    return;
  }

  const approveTx = await sourceChainClient.sendTransaction({
    to: frxUsdTokenAddress,
    data: encodeFunctionData({
      abi: [
        {
          type: 'function',
          name: 'approve',
          stateMutability: 'nonpayable',
          inputs: [
            { name: 'spender', type: 'address' },
            { name: 'amount', type: 'uint256' },
          ],
          outputs: [{ name: '', type: 'bool' }],
        },
      ],
      functionName: 'approve',
      args: [spenderAddress, TRANSFER_AMOUNT], // Set max allowance in wei (change as needed)
    }),
  });
  console.log(`frxUSD Approval Tx: ${approveTx}`);
}

async function retrieveQuote(sourceChainClient, spenderAddress, destinationEid) {
  console.log('Retrieving quote...');
  const quote = await sourceChainClient.readContract({
    address: spenderAddress,
    data: encodeFunctionData({
      abi: [
        {
          inputs: [
            {
              components: [
                { internalType: 'uint32', name: 'dstEid', type: 'uint32' },
                { internalType: 'bytes32', name: 'to', type: 'bytes32' },
                { internalType: 'uint256', name: 'amountLD', type: 'uint256' },
                { internalType: 'uint256', name: 'minAmountLD', type: 'uint256' },
                { internalType: 'bytes', name: 'extraOptions', type: 'bytes' },
                { internalType: 'bytes', name: 'composeMsg', type: 'bytes' },
                { internalType: 'bytes', name: 'oftCmd', type: 'bytes' },
              ],
              internalType: 'struct SendParam',
              name: '_sendParam',
              type: 'tuple',
            },
            { internalType: 'bool', name: '_payInLzToken', type: 'bool' },
          ],
          name: 'quoteSend',
          outputs: [
            {
              components: [
                { internalType: 'uint256', name: 'nativeFee', type: 'uint256' },
                { internalType: 'uint256', name: 'lzTokenFee', type: 'uint256' },
              ],
              internalType: 'struct MessagingFee',
              name: 'msgFee',
              type: 'tuple',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
      ],
      functionName: 'quoteSend',
      args: [
        {
          dstEid: destinationEid,
          to: DESTINATION_ADDRESS_BYTES32,
          amountLD: TRANSFER_AMOUNT,
          minAmountLD: (TRANSFER_AMOUNT * 99n) / 100n,
          extraOptions: '0x',
          composeMsg: '0x',
          oftCmd: '0x',
        },
        false,
      ],
    }),
  });
  const nativeFee = quote.nativeFee;
  return nativeFee;
}

async function transferFrxUSD(sourceChainClient, spenderAddress, destinationEid) {
  console.log('Transferring frxUSD...');
  const nativeFee = await retrieveQuote(
    sourceChainClient,
    spenderAddress,
    destinationEid,
  );
  const transferTx = await sourceChainClient.sendTransaction({
    to: spenderAddress,
    value: nativeFee,
    data: encodeFunctionData({
      abi: [
        {
          inputs: [
            {
              components: [
                { internalType: 'uint32', name: 'dstEid', type: 'uint32' },
                { internalType: 'bytes32', name: 'to', type: 'bytes32' },
                { internalType: 'uint256', name: 'amountLD', type: 'uint256' },
                { internalType: 'uint256', name: 'minAmountLD', type: 'uint256' },
                { internalType: 'bytes', name: 'extraOptions', type: 'bytes' },
                { internalType: 'bytes', name: 'composeMsg', type: 'bytes' },
                { internalType: 'bytes', name: 'oftCmd', type: 'bytes' },
              ],
              internalType: 'struct SendParam',
              name: '_sendParam',
              type: 'tuple',
            },
            {
              components: [
                { internalType: 'uint256', name: 'nativeFee', type: 'uint256' },
                { internalType: 'uint256', name: 'lzTokenFee', type: 'uint256' },
              ],
              internalType: 'struct MessagingFee',
              name: '_fee',
              type: 'tuple',
            },
            { internalType: 'address', name: '_refundAddress', type: 'address' },
          ],
          name: 'send',
          outputs: [
            {
              components: [
                { internalType: 'bytes32', name: 'guid', type: 'bytes32' },
                { internalType: 'uint64', name: 'nonce', type: 'uint64' },
                {
                  components: [
                    { internalType: 'uint256', name: 'nativeFee', type: 'uint256' },
                    { internalType: 'uint256', name: 'lzTokenFee', type: 'uint256' },
                  ],
                  internalType: 'struct MessagingFee',
                  name: 'fee',
                  type: 'tuple',
                },
              ],
              internalType: 'struct MessagingReceipt',
              name: 'msgReceipt',
              type: 'tuple',
            },
            {
              components: [
                { internalType: 'uint256', name: 'amountSentLD', type: 'uint256' },
                {
                  internalType: 'uint256',
                  name: 'amountReceivedLD',
                  type: 'uint256',
                },
              ],
              internalType: 'struct OFTReceipt',
              name: 'oftReceipt',
              type: 'tuple',
            },
          ],
          stateMutability: 'payable',
          type: 'function',
        },
      ],
      functionName: 'send',
      args: [
        {
          dstEid: destinationEid,
          to: DESTINATION_ADDRESS_BYTES32,
          amountLD: TRANSFER_AMOUNT,
          minAmountLD: (TRANSFER_AMOUNT * 99n) / 100n,
          extraOptions: '0x',
          composeMsg: '0x',
          oftCmd: '0x',
        },
        { nativeFee: nativeFee, lzTokenFee: 0n },
        account.address,
      ],
    }),
  });
  console.log(`Transfer Tx: ${transferTx}`);
}

async function main() {
  const { spenderAddress, sourceChainClient, frxUsdTokenAddress, destinationEid } =
    getTransferConfig();

  console.log(`Transferring frxUSD from ${SOURCE_CHAIN} to ${DESTINATION_CHAIN}`);
  console.log(`Using spender address: ${spenderAddress}`);
  console.log(`Destination EID: ${destinationEid}`);

  await approveFrxUSD(sourceChainClient, frxUsdTokenAddress, spenderAddress);
  await transferFrxUSD(sourceChainClient, spenderAddress, destinationEid);
  console.log('frxUSD transfer completed!');
}

main().catch(console.error);
```

The `transfer.js` script provides a complete **end-to-end** solution for transferring frxUSD using Frax's cross-chain infrastructure with a **non-custodial wallet**. In the next section, you can test the script.

## Test the script

To test the script, run the following command:

```shell
node transfer.js
```

Once the script runs and the transfer is finalized, a **confirmation receipt** is logged in the console.

## What's next

- [Mint & Redeem frxUSD](/frxusd/mint-and-redeem-overview)
